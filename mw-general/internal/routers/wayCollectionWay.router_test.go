package routers

import (
	"context"
	"mwserver/internal/auth"
	"mwserver/internal/config"
	"mwserver/internal/openapi"
	"net/http"
	"testing"

	openapiGeneral "mwserver/apiAutogenerated/general"

	"github.com/stretchr/testify/assert"
)

func TestCreateWayCollectionWay(t *testing.T) {
	newConfig, err := config.LoadConfig("../../")
	if err != nil {
		t.Fatalf("Failed to load config: %v", err)
	}

	generalApi := openapi.MakeGeneralAPIClient(&newConfig)
	_, err = generalApi.DevAPI.DevResetDbGet(context.Background()).Execute()
	if err != nil {
		t.Fatalf("Failed to reset db: %v", err)
	}

	currentUserID := "1b3d5e7f-5a1e-4d3a-b1a5-d1a1d5b7a7e1"
	wayCollectionID := "30dbf616-b055-4d65-8c0c-e6a913fc119a"
	wayID := "aa13eee9-7dca-46ed-a3f7-21d8b7ae3b72"

	t.Run("should add a way to a user's custom way collection and verify its addition", func(t *testing.T) {
		token, err := auth.GenerateJWT(currentUserID, newConfig.SecretSessionKey)
		if err != nil {
			t.Fatalf("Failed to generate JWT: %v", err)
		}

		request := openapiGeneral.SchemasCreateWayCollectionWay{
			WayCollectionUuid: wayCollectionID,
			WayUuid:           wayID,
		}

		ctx := context.WithValue(context.Background(), auth.ContextKeyAuthorization, "Bearer "+token)
		wayCollectionResponse, response, err := generalApi.WayCollectionWayAPI.CreateWayCollectionWay(ctx).Request(request).Execute()
		if err != nil {
			t.Fatalf("Failed to create WayCollection: %v", err)
		}

		expectedData := &openapiGeneral.SchemasWayCollectionWayResponse{
			WayCollectionId: wayCollectionID,
			WayId:           wayID,
		}

		assert.Equal(t, http.StatusOK, response.StatusCode)
		assert.Equal(t, expectedData.WayId, wayCollectionResponse.WayId)
		assert.Equal(t, expectedData.WayCollectionId, wayCollectionResponse.WayCollectionId)
	})
}

func TestDeleteWayCollectionWayById(t *testing.T) {
	newConfig, err := config.LoadConfig("../../")
	if err != nil {
		t.Fatalf("Failed to load config: %v", err)
	}

	generalApi := openapi.MakeGeneralAPIClient(&newConfig)
	_, err = generalApi.DevAPI.DevResetDbGet(context.Background()).Execute()
	if err != nil {
		t.Fatalf("Failed to reset db: %v", err)
	}

	currentUserID := "1b3d5e7f-5a1e-4d3a-b1a5-d1a1d5b7a7e1"
	wayCollectionID := "30dbf616-b055-4d65-8c0c-e6a913fc119a"
	wayID := "a2cb5e1b-44df-48d3-b7a1-34f3d7a5b7e2"

	t.Run("should delete a way from a user's custom way collection and verify its removal", func(t *testing.T) {
		token, err := auth.GenerateJWT(currentUserID, newConfig.SecretSessionKey)
		if err != nil {
			t.Fatalf("Failed to generate JWT: %v", err)
		}

		ctx := context.WithValue(context.Background(), auth.ContextKeyAuthorization, "Bearer "+token)
		response, err := generalApi.WayCollectionWayAPI.DeleteWayCollectionWay(ctx, wayCollectionID, wayID).Execute()
		if err != nil {
			t.Fatalf("Failed to create WayCollection: %v", err)
		}

		assert.Equal(t, http.StatusNoContent, response.StatusCode)

		user, userResponse, err := generalApi.UserAPI.GetUserByUuid(ctx, currentUserID).Execute()
		if err != nil {
			t.Fatalf("Failed to get user: %v", err)
		}

		expectedData := &openapiGeneral.SchemasUserPopulatedResponse{
			CustomWayCollections: []openapiGeneral.SchemasWayCollectionPopulatedResponse{},
			Uuid:                 currentUserID,
		}

		assert.Equal(t, userResponse.StatusCode, userResponse.StatusCode)
		assert.Equal(t, expectedData.Uuid, user.Uuid)

		isWayCollectionExists := false
		for _, customWayCollections := range user.CustomWayCollections {
			// Search needed customWayCollections, which includs wayID
			if customWayCollections.Uuid == wayCollectionID {
				isWayCollectionExists = true
				for _, way := range customWayCollections.Ways {
					// Search needed way by id, to make sure that it was deleted from this customWayCollections
					if way.Uuid == wayID {
						t.Fatalf("wayID %s wasn't removed from customWayCollections %s", wayID, wayCollectionID)
					}
				}
			}
			break
		}

		if !isWayCollectionExists {
			t.Fatalf("wayCollectionID %s does not exist for this user", wayCollectionID)
		}
	})
}
